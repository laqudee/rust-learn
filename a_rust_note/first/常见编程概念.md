# 变量与可变性

- 变量默认是不可变的

- rust编译器保证，如果声明一个值不会变，它就真的不会变

- 常量
  - const，永远不能被修改

```rs
  const THREE_HOURS_IN_SECONDS: U32 = 60 * 60 * 3；
```

- 隐藏
  - Shadowing
  - 前一个变量被第二个变量隐藏了，这意味着当使用变量的名称时，编译器将看到第二个变量。
  - 第二个变量遮蔽了第一个变量。

  - mut 与隐藏还是有区别的。当不小心尝试对变量重新赋值时，如果没有使用let关键字，就会导致编译时错误。
  - 通过使用 let，我们可以用这个值进行一些计算，不过计算完之后变量仍然是不可变的。

  - 另一个区别，当再次使用 let 时，实际上创建了一个新变量，我们可以改变值的类型，并且复用这个名字。

  ```rs
    let spaces = "     "; // String
    let spaces = spaces.len(); // Int
  ``` 

  ```rs
    let mut spaces = "    " 
    spaces = spaces.len() // error
  ```

# 数据类型

- 标量scalar
- 复合compound

- rust是静态类型（statically typed），编译时就必须知道所有变量的类型

- 标量类型
  - 代表一个单独的值。
  - 四种基本的标量类型：整型、浮点型、布尔型、字符类型。

- 整型（有符号的可以为负数，无符号的只能是正数），-2(n-1) ~ 2(n-1)
  - i8, u8
  - i16, u16
  - i32, u32
  - i64, u64
  - i128, u128
  - isize, usize, 该类型依赖运行程序的计算机架构：64位架构上它们是64位的，32位架构上是32位的。

- 十进制 ----- 98_222
- 十六进制0x ------ 0xff
- 八进制0o ------ 0o77
- 二进制0b ----- 0b11101100
- 单字节字符（仅限于u8）b ------ b'A'

- 整型溢出
  - debug模式，编译时报错
  - release构建中，rust不检测溢出，相反会进行一种被称为二进制补码回绕的操作。

  - wrapping_*
  - checked_*
  - overflow_*
  - saturating_*

- 浮点型, 默认f64
  - f32
  - f64

```rs
  fn main () {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
  }
```

- 数值运算
  - 

# 宏

- 什么是宏？
- 宏怎么工作？

- 宏Macro指的是Rust中一系列的功能：使用macro_rules!的声明宏，和三种过程宏
    - 自定义`#[derive]`宏在结构体和枚举上指定通过dervie属性添加的代码
    - 类属性宏定义可用于任意项的2自定义属性
    - 类函数宏看起来像函数不过作用于参数传递的token

## 宏和函数的区别
- 从根本上来说，宏是一种为写其他代码而写代码的方式，即所谓的元编程

- 元编程对于减少大量编程和维护的代码是非常有用的，它也扮演了函数扮演的角色。但宏有函数所没有的附加功能

- 实现宏不如实现函数的一面是宏定义要比函数定义更复杂，因为你正在编写生成 Rust 代码的 Rust 代码。由于这样的间接性，宏定义通常要比函数定义更难阅读、理解以及维护

- 宏和函数的最后一个重要区别是：在一个文件里调用宏之前必须定义它或将其引入作用域，而函数则可以在任何地方定义和调用

## 使用macro_rules!的声明宏用于通用元编程

- 声明宏允许我们编写一些类似Rust match 表达式的代码

- `#[macro_export]`，注解表明只要导入了定义这个宏的crate，该宏就应该是可用的。

- `macro_rules!`，用来定义宏

- 分支模式`( $( $x:expr ),* )`

- 宏模式匹配的是Rust代码结构而不是值

- macro 关键字

## 用于从属性生成代码的过程宏
- 更像函数，接收Rust代码作为输入，产生另一些代码作为输出

- 三种过程宏：
  - 自定义派生derive
  - 类属性
  - 类函数

## 如何编写自定义derive宏


## 类属性宏

## 类函数宏
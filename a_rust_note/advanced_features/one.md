# 高级特征

- 不安全rust，用于当需要舍弃Rust的某些保证并负责手动维持这些保证
- 高级trait，与trait相关的关联类型
- 高级类型
- 高级函数和闭包
- 宏

# 不安全Rust

- 静态分析本质上是保守的

- 代码可能是合法的，但编译器没有足够的信息来确认

- 底层计算机硬件固有的不安全性

## 不安全的超能力
- unsafe关键字来切换到不安全rust，接着开启一块新的代码块存放代码

- 五类不安全的超能力
  - 解引用裸指针
  - 调用不安全的函数或方法
  - 访问或修改可变静态变量
  - 实现不安全trait
  - 访问union的字段


## 解引用裸指针

- *const T，不可变裸指针
- *mut T，可变裸指针

- 裸指针与智能指针的区别：
  - 允许忽略借用规则，可以同时存在不可变与可变的指针，或多个指向相同位置的可变指针
  - 不保证指向有效的内存
  - 允许为空
  - 不能实现任何自动清理功能

```rs
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
```

- 创建一个指针不会造成任何危险；只有当访问其指向的值时，才有可能遇到无效的值

- 裸指针的一个主要应用场景就是调用C代码接口，另一个场景就是构建借用检查器无法理解的安全抽象

## 调用不安全函数或方法

- 使用unsafe标记不安全函数或方法

```rs
unsafe fn dangerous() {}

unsafe {
    dangerous()
}

```

- 不安全函数体也是有效的unsafe块，所以在不安全函数中进行另一个不安全操作时无需新增额外的unsafe块

## 创建不安全代码的安全抽象

- 仅仅因为函数包含不安全代码并不意味着整个函数都需要标记为不安全

- 将不安全代码封装进安全函数是一个常见的抽象

- slice是一个指向一些数据的指针，并带有该slice的长度
- as_mut_ptr()访问slice的裸指针

- slice::from_raw_parts_mut函数是不安全的因为它获取了一个裸指针，并确信这个指针是有效的

## 使用extern函数调用外部代码

- 有时你的rust代码可能需要与其他语言编写的代码交互

- extern，有助于创建和使用外部函数接口FFI

- 外部函数接口是一个编程语言用于定义函数的方式，其允许不同外部编程语言调用这些函数

- 从其他语言调用rust函数
  - extern
  - `#[no_mangle]`

```rs
#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
```

## 访问或修改可变静态变量

- 全局变量在rust中被称为静态变量static

```rs
static HELLO_WORLD: &str = "hello wrold";
```

- `static`，只能存储拥有'static生命周期额引用

- 访问不可变静态变量是安全的

- 常量与不可变静态变量的区别：
  - 静态变量中的值有一个固定的内存地址。使用这个值总是会访问相同的地址。另一方面，常量则允许在任何被用到的时候复制其数据
  - 静态变量是可以是可变的。访问和修改可变静态变量都是不安全的

## 实现不安全trait
- unsafe的另一个操作用例是实现不安全的trait。

```rs
unsafe trait Foo {

}
unsafe impl Foo for i32 {
    
}
```

## 访问联合体中的字段
- 仅适用于unsafe的最后一个操作是访问联合体中的字段

- union

- 联合体主要用于和C代码中的联合体交互
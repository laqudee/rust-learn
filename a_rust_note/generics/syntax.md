# 泛型、Trait和生命周期

- 泛型是具体类型或其他属性的抽象替代。可以表达泛型的属性，比如泛型的行为或如何与其他泛型相关联

- 使用泛型定义我们自己的类型、函数和方法

- 泛型函数
- 结构体和枚举定义中的泛型

- trait，这是一个定义泛型行为的方法

- 生命周期

# 泛型数据类型
- 如何使用泛型定义函数、结构体、枚举和方法

- 在函数定义中使用泛型

```rs
  fn largest<T>(list: $[T]) -> T {}
```

- `std::cmp::PartialOrd` trait可以实现类型的比较功能

- 结构体定义中的泛型
  - 同样可以使用`<>`语法来定义结构体，它包含一个或多个泛型参数类型字段

- 枚举定义中的泛型
```rs
  enum Option<T> {
    Some(T),
    None,
  }

  enum Result<T, E> {
    Ok(T),
    Err(E),
  }
```

- 方法中定义的泛型
  - 在为结构体和枚举实现方法是，也可以使用泛型
  - 另一个选择就是定义方法适用于某些有限制的泛型。

```rs
impl Point<f32> {
  fn distance_from_origin(&self) -> f32 {
    (self.x.powi(2) + self.y.powi(2).sqrt())
  }
}

// 这段代码意味着 Point<f32> 类型会有一个方法 distance_from_origin，而其他 T 不是 f32 类型的 Point<T> 实例则没有定义此方法
```

- 结构体定义中的泛型参数并不总是与结构体方法签名中使用的泛型是同一类型

- 泛型代码的性能
  - rust实现了泛型，使得使用泛型类型的代码相比于使用具体类型并没有任何速度上的损失

- 单态化：通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程



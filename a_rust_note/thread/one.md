# 线程与move闭包

- move关键字经常用于传递给thread::spawn的闭包，因为闭包会获取从环境中获取的值得所有权，因此会将这些值的所有权从一个线程传递给另一个线程

- move关键字强制闭包获取其使用的环境值的所有权

# 使用消息传递在线程间传递数据

- 消息传递message passing，这里线程或actor通过发送包含数据的消息来相互沟通

- 来源于go：不要通过共享内存来通讯，而是通过通讯来共享内存

- rust中一个实现消息传递并发的主要工具是信道

- 发送者
- 接收者

- mpsc::channel函数创建一个新的信道
  - 返回一个元组，第一个元素是发送端，第二个元素是接收端
- mpsc是多个生产者，单个消费者的缩写

- rust标准库实现信道的方式意味着一个信道可以有多个产生值的发送端，但只能有一个消费这些值的接收端

- 解构

- send方法用于获取需要放入信道的值
  - 返回`Result<T, E>`类型

- 信道的接收端有两个有用的方法：recv、try_recv
  - recv会阻塞主线程执行直到从信道接收一个值，一旦发送了一个值，recv会在一个`Result<T, E>`中返回它
  - try_recv不会阻塞，立即返回一个`Result<T, E>`

- 如果线程在等待消息过程中还有其他工作时使用 try_recv 很有用：可以编写一个循环来频繁调用 try_recv，在有可用消息时进行处理，
- 其余时候则处理一会其他工作直到再次检查。

## 信道与所有权转移

- 尝试在新建信道中发送完val值之后再使用之

- 坏主意：一旦将值发送到另一个线程后，那个线程可能会在我们再次使用它之前就将其修改或者丢弃
- 其他线程对值可能的修改会由于不一致或不存在的数据而导致错误或意外的结果

- send函数获取其参数的所有权并移动这个值归接受者所有

- 这可以防止在发送后再次意外地使用这个值；所有权系统检查一切是否合乎规则

## 发送多个值并观察接受者的等待

- 在主线程中，不再显式调用recv函数：而是将rx当作一个迭代器。对于每一个接收到的值，将之打印出来

## 通过克隆发送者来创建多个生产者

- clone()

# 共享状态并发

- 虽然消息传递是一个很好的处理并发的方式，但并不是唯一一个。

- Go编程语言文档中口号的一部分：不要通过共享内存来通讯

- 在某种程度上，任何编程语言中的信道都类似于单所有权，因为一旦将一个值传送到信道中，将无法再使用这个值。

- 共享内存类似于多所有权：多个线程可以同时访问相同的内存位置。

- 互斥器

## 互斥器一次只允许一个线程访问数据

- mutex互斥器

- 锁lock
  - 是一个作为互斥器一部分的数据结构，它记录谁有数据的排他访问权

- 互斥器为通过锁系统保护其数据

- 互斥器特点：
  - 在使用数据之前尝试获取锁
  - 处理完互斥器所保护的数据之后，必须解锁数据，这样其他线程才能获取锁

## `Mutex<T>`的API

- 使用关联函数new来创建一个`Mutex<T>`。

- 使用lock方法获取锁，以访问互斥器中的数据。这个调用会阻塞当前线程，直到我们拥有锁为止

- `Mutex<T>`是一个智能指针。更准确的说，lock调用返回一个叫做MutexGuard的智能指针。

## 线程间共享`Mutex<T>` 

- 将启动十个线程，并在各个线程中对同一个计数器值加一。

## 多线程和多所有权

- 通过使用智能指针 `Rc<T>` 来创建引用计数的值，以便拥有多所有者

- `Rc<T>`并不能安全的在线程间共享，所以我们需要的是一个完全类似`Rc<T>`  ，又以一种安全的方式改变引用计数的类型

## 原子引用计数`Arc<T>`

- 原子引用计数类型

- 原子性是另一类并发原语

- 原子类就像基本类型一样可以安全的在线程间共享

## `RefCell<T>`/`Rc<T>`与`Mutex<T>`/`Arc<T>`的相似性

- `Mutex<T>` 提供了内部可变性，就像 Cell 系列类型那样

- 使用 `RefCell<T>` 可以改变 `Rc<T> `中的内容那样，同样的可以使用 `Mutex<T>` 来改变 `Arc<T> `中的内容

- Mutex也会造成死锁

# 使用Sync和Send trait的可扩展并发

- rust的并发模型中一个有趣的方面是：语言本身对并发知之甚少。

- 所以我们编写自己的或使用别人编写的并发功能

- 有两个并发概念是内嵌于语言中的std::marker中的Sync和Send trait

## 通过Send允许在线程间转移所有权

- Send标记trait表明实现了Send的类型值的所有权可以在线程间传递

- 几乎所有的 Rust 类型都是Send 的，不过有一些例外，包括 `Rc<T>`：这是不能 Send 的，因为如果克隆了 `Rc<T> `的值并尝试将克隆的所有权转移到另一个线程，这两个线程都可能同时更新引用计数

- `Rc<T>`被实现为用于单线程场景，这时不需要为拥有线程安全的引用计数而付出性能代价

- Rust 类型系统和 trait bound 确保永远也不会意外的将不安全的 Rc<T> 在线程间发送

- 任何完全由 Send 的类型组成的类型也会自动被标记为 Send。几乎所有基本类型都是 Send 的，除了裸指针（raw pointer）

## Sync允许多线程访问

- Sync 标记 trait 表明一个实现了 Sync 的类型可以安全的在多个线程中拥有其值的引用

- 换一种方式来说，对于任意类型 T，如果 &T（T 的不可变引用）是 Send 的话 T 就是 Sync 的，这意味着其引用就可以安全的发送到另一个线程

- 类似于Send的情况，基本类型是Sync的，完全由Sync的类型组成的类型也是Sync的

- 智能指针 `Rc<T>` 也不是 Sync 的，出于其不是 Send 相同的原因。`RefCell<T>`（第十五章讨论过）和 `Cell<T> `系列类型不是 Sync 的。`RefCell<T>` 在运行时所进行的借用检查也不是线程安全的

- `Mutex<T>`是Sync的，可以被用来在多线程中共享访问

## 手动实现Send和Sync是不安全的

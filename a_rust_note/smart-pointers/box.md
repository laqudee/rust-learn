# 使用`Box<T>`指向堆上的数据

- 最简单直接的智能指针是box，其类型是`Box<T>`
    - 允许将一个值放在堆上而不是栈上

- 场景：
    - 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候
    - 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候
    - 当希望拥有一个值并只关系它的类型是否实现了特定trait而不是其具体类型的时候

- trait对象

## 使用`Box<T>`在堆上储存数据

```rs
    let b = Box::new(5);
```

- 这个释放过程作用于box本身（位于栈上）和它所指向的数据（位于堆上）

## Box允许创建递归类型

- 一种无法在编译时知道大小的类型是递归类型，其值的一部分可以是相同类型的另一个值。

- `cons list`，函数式编程语言中常见的类型
    - cons list的每一项都包含两个元素：当前项与下一项。其最后一项值包含一个叫做Nil的值且没有下一项。
    - cons list通过调用cons函数产生

```rs
    enum list {
        Cons(i32, List),
        Nil,
    }
```

## 使用`Box<T>`给递归类型一个已知的大小

- rust无法计算出要为定义为递归的类型分配多少空间。

- `Box<T>`只提供了间接存储和堆分配

- `Box<T>` 类型是一个智能指针，因为它实现了 Deref trait，它允许 `Box<T>` 值被当作引用对待。当 Box`<T>` 值离开作用域时，由于 `Box<T>` 类型 Drop trait 的实现，box 所指向的堆数据也会被清除
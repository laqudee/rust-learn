# `Rc<T>`引用计数智能指针

- 大部分情况下所有权是非常明确的：可以准确地知道哪个变量拥有某个值

- 有些情况下单个值可能会有多个所有者。例如在图结构中，多个边可能指向相同的节点；节点直到没有任何边指向它之前都不应被清理

- 启用多所有权，rust有一个叫做`Rc<T>`的类型，引用计数
  - 引用计数意味着记录一个值引用的数量来知晓这个值是否仍然被使用

- `Rc<T>`用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的哪一部分会最后结束使用它的时候

- 如果确实知道哪部分是最后一个结束使用的话，就可以令其成为数据的所有者，正常的所有权规则就可以在编译时生效

- `Rc<T>`只能用于单线程场景

## 使用`Rc<T>`共享数据

- 不能用2个`Box<T>`的列表尝试共享第三个列表的所有权

- 可以改变Cons的定义来存放一个引用，不过接着必须指定生命周期参数。通过指定生命周期函数，表明列表中的每一个元素都至少与列表本身存在的一样久

- 相反，我们修改 List 的定义为使用 `Rc<T>` 代替 `Box<T>`

- 需要使用 use 语句将 `Rc<T>` 引入作用域，因为它不在 prelude 中

- Rc::clone(&value)的实现并不像大部分类型的clone实现那样对所有数据进行深拷贝
  - Rc::clone只会增加引用计数

- 通过使用 Rc::clone 进行引用计数，可以明显的区别深拷贝类的克隆和增加引用计数类的克隆。

- 当查找代码中的性能问题时，只需考虑深拷贝类的克隆而无需考虑 Rc::clone 调用

## 克隆`Rc<T>`会增加引用计数

- Rc::strong_count()函数获取引用计数的值

- `Rc<T>`也有weak_count，在避免引用循环中会使用到

- Drop trait 的实现当 `Rc<T>` 值离开作用域时自动减少引用计数

- 通过不可变引用，`Rc<T>`允许在程序的多个部分之间只读地共享数据

- 内部可变性模式和 RefCell<T> 类型，它可以与 Rc<T> 结合使用来处理不可变性的限制